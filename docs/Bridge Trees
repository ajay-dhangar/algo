/* 
Bridges are those edges in a graph, which upon removal from the graph will make it disconnected.
The idea of a bridge tree is to shrink the maximal components without a bridge into one node, leaving only the bridges of the original graph as the edges in the bridge tree.

Properties of the bridge tree -->
1. All the bridges of the original graph are represented as edges in the bridge tree.
2. The bridge tree is connected if the original graph is connected.
3. The bridge tree does not contain any cycles.
4. The bridge tree will contain ≤ N nodes, where N is the number of nodes in the original graph.
5. The bridge tree will contain ≤ N−1 edges, where N is the number of nodes in the original graph.

The time complexity of making the bridge tree
In this section, N stands for the number of nodes and M stands for the number of edges in the original graph. The bridges in the graph can be found in O(N+M).
The time complexity for the DFS function is O(N+M). Note that we can store the ID of the edge alongside the adjacent node in the adjacency list. We can have 
an array isBridge, and mark isBridge[edge] = true for every edge which is a bridge. During the DFS, just check if the current edge is marked as a bridge using its stored ID.

Thus the total time complexity will be O((N+M)+(N+M)), which is equivalent to O(N+M).

*/
// Pseudocode for making the bridge tree
// Function to perform DFS and find bridges
function dfs(node, componentNumber) {
    component[node] = componentNumber; // Mark the component for the node
    vis[node] = true; // Mark this node as visited

    // Iterate through each adjacent edge that is not a bridge
    for (each adjacentEdge in adjacencyList[node]) {
        next = otherEndpoint(adjacentEdge); // Get the other endpoint of the edge

        // If the next node has already been visited, skip it
        if (vis[next] === true) {
            continue; // Already visited this node
        }
        
        // Recursively call DFS for the next node
        dfs(next, componentNumber);
    }
}

// Main function to execute the bridge-finding algorithm
function main() {
    findAllBridges(); // Function to find all the bridges in the graph

    // Loop through each node in the graph
    for (let i = 0; i < n; i++) { // Assume n is the total number of nodes
        if (vis[i] === false) { // If the node has not been visited
            dfs(i, uniqueComponentNumber); // Call DFS with a unique component number
            uniqueComponentNumber++; // Increment the component number for the next call
        }
    }
}

// Assume additional helper functions are defined:
// - findAllBridges: to find all the bridges in the graph
// - otherEndpoint: to get the other endpoint of an edge
